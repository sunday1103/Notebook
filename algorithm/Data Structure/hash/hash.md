# 散列表

[TOC]

## 直接寻址表

直接寻址表，就是表的索引就是关键字本身，比如数组的下标就可以是直接寻址表的索引。

> - 数组存储是典型的直接寻址表；
> - bitmap也是典型的直接寻址表；

> 问题：非常大的数组进行直接寻址方式实现字典，怎么实现。（不能进行初始化操作）
>
> > 使用另外一个数组（链表etc）存储数据，此时大数组扮演的角色是快速获取真正数组的地址。
> >
> > https://walkccc.github.io/CLRS/Chap11/11.1/

## 散列表

当key值很大时候，直接寻址方法不可实现，这个时候需要将关键字映射到散列表的**slot**上，即：
$$
表的索引（slot） = hash(关键字)
$$
==冲突==

不同关键字映射到相同的slot上的情形称为**冲突**。

### 冲突解决方法1：链接法

每个slot指向一个链表，使用链表存储实际值。

> 均匀散列的情况下采用双向链表的散列表的“插入、查找、删除”操作的时间复杂度都是O(1)
>
> 为什么查找的时间复杂度也是O(1)：
>
> - 前提：散列表的大小是n，slot数是m，假设n与m成正比，也就是n = O(m)
> - 查找操作的时间复杂度是：O(每个slot上的元素个数)
> - 在均匀散列的情况下，每个slot上元素个数是：n/m，即O(n/m) = O(n)/m = O(m)/m = O(1)

### 冲突解决方法2：开放寻址法

所有元素都放在散列表中，在插入的时候如果遇到冲突，就找到下一个插入位置。

```c
插入：
HASH-INSERT(T, k)
    i = 0
    repeat
    	j = h(k, i)
    	if T[j] == NUL
    		T[j] = k
    		return j
    	else i = i + 1
	until i == m
error "overflow"
```

其中 h(k, i)是开放寻址法的散列函数，该函数根据关键字和探查序号生成散列值。

针对同一关键字，散列函数能保证，具有同样的探查序列。

这样就可以在查找的时候按照插入的探查序列进行查找。

```c
查找：
HASH-SEARCH(T, k)
	i = 0
	repeat
		j = h(k, i)
		if T[j] == k
			return j
		i = i + 1
	until T[j] == NIL or i == m
	return NIL
```

使用插入时候相同的探查顺序进行查找，如果某个位置上元素为NIL，那么久表示该元素不存在T中。

那么怎么处理删除操作：

```c
删除：
HASH-DELETE(T, k)
	j = HASH-SEARCH(T, k)
	if j != NIL
		T[j] = DELETED
		return 
    return not find
```

通过这种方式，就需要更改插入的操作，如果某个slot上是DELETED，那么也进行插入操作。

>实际应用中 ，如果散列表需要删除，往往使用链接法来解决冲突。

#### 线性探查

$$
h(k, i) = (h'(k) + i) mod m, i = 0,1,2...
$$

其中，h'(k)是一个辅助散列函数，生成初始探查位置。也就是每次探查位置在第一个位置上加1.

> 一次集群：
>
> 假设h(k, i)是被占用的，那么k就会继续查找下一个位置h(k, i+1)，这样导致位置h(k, i+1)被占用。那么导致初始散列到该位置的关键字又需要继续查找位置，这样就导致这一片区域都处于被占用状态。会影响整体的平均查找时间。

#### 二次探查
$$
h(k, i) = (h'(k) + c1*i + c2*i^2) mod m, i = 0,1,2...
$$

也就是每次探查位置在第一个位置上加上关于i的二次函数.

> 二次集群：
>
> 虽然避免了一次集群的问题，但是当$h’(k)== h'(k')$时候，也会导致后续所有查找序列一致，那么这一系列的位置上就会出现一次集群一样的现象。

#### 双重探查

$$
h(k, i) = (h'(k) + i *h''(k)) mod m, i = 0,1,2...
$$

也就是每次探查位置在第一个位置上加上探查次数 * 随机值。

> 这样初始探查位置和偏移量都是根据关键字决定的了，就很大程度避免了二次探查的问题。

#### 探查方式需要保证m次探查能够遍历所有slot

- 线性探查，因为每次探查是在初始探查位置的基础上增加一个位置，所有可以天然保证该点；
- 二次探查，常采用的系数是1/2 和 1/2
- 双重探查，需要保证h''(k)和m互为素数

### 散列函数

#### 原则

散列函数的原则是尽量的进行均匀散列。

> **散列关键字转换为自然数**
>
> 散列函数很多都是以自然数为关键字，所以在实际应用中，需要将其他类型的关键字转换为自然数。比如字符串就可以使用ASCII码的和。

#### 除法散列

$$
h(k) = k mod m
$$

m表示散列表的slot数。

> m如果是2的整次幂，那么h(k)就是k的低若干个bit。这样的散列不是好的散列方式，因为只是使用了k的低若干个bit信息，这样很可能不能够均匀散列。（除非明确知道低若干个bit是均匀分布的）

#### 乘法散列

$$
h(k) = 向下取整(m(kA mod 1))
$$

其中A表示（0,1）之间的常数。

Knuth建议为：$(sqrt(5) - 1)/2$

#### 全域散列

略

